
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE1_SOC_D8M_RTL(

	//////////// ADC //////////
	output		          		ADC_CONVST,
	output		          		ADC_DIN,
	input 		          		ADC_DOUT,
	output		          		ADC_SCLK,

	//////////// Audio //////////
	input 		          		AUD_ADCDAT,
	inout 		          		AUD_ADCLRCK,
	inout 		          		AUD_BCLK,
	output		          		AUD_DACDAT,
	inout 		          		AUD_DACLRCK,
	output		          		AUD_XCK,

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		    [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// I2C for Audio and Video-In //////////
	output		          		FPGA_I2C_SCLK,
	inout 		          		FPGA_I2C_SDAT,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// IR //////////
	input 		          		IRDA_RXD,
	output		          		IRDA_TXD,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// Video-In //////////
	input 		          		TD_CLK27,
	input 		     [7:0]		TD_DATA,
	input 		          		TD_HS,
	output		          		TD_RESET_N,
	input 		          		TD_VS,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// GPIO_1, GPIO_1 connect to D8M-GPIO //////////
	output 		          		CAMERA_I2C_SCL,
	inout 		          		CAMERA_I2C_SDA,
	output		          		CAMERA_PWDN_n,
	output		          		MIPI_CS_n,
	inout 		          		MIPI_I2C_SCL,
	inout 		          		MIPI_I2C_SDA,
	output		          		MIPI_MCLK,
	input 		          		MIPI_PIXEL_CLK,
	input 		     [9:0]		MIPI_PIXEL_D,
	input 		          		MIPI_PIXEL_HS,
	input 		          		MIPI_PIXEL_VS,
	output		          		MIPI_REFCLK,
	output		          		MIPI_RESET_n,
	//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
	inout 		    [35:0]		GPIO 	
	
);
//=============================================================================
// REG/WIRE declarations
//=============================================================================


wire	[15:0]SDRAM_RD_DATA;
wire			DLY_RST_0;
wire			DLY_RST_1;
wire			DLY_RST_2;

wire			SDRAM_CTRL_CLK;
wire        D8M_CK_HZ ; 
wire        D8M_CK_HZ2 ; 
wire        D8M_CK_HZ3 ; 

wire [7:0] RED   ; 
wire [7:0] GREEN  ; 
wire [7:0] BLUE 		 ; 
wire [12:0] VGA_H_CNT;			
wire [12:0] VGA_V_CNT;	

wire        READ_Request ;
wire 	[7:0] B_AUTO;
wire 	[7:0] G_AUTO;
wire 	[7:0] R_AUTO;
wire        RESET_N  ; 

wire        I2C_RELEASE ;  
wire        AUTO_FOC ; 
wire        CAMERA_I2C_SCL_MIPI ; 
wire        CAMERA_I2C_SCL_AF;
wire        CAMERA_MIPI_RELAESE ;
wire        MIPI_BRIDGE_RELEASE ;  

//changed wire to reg for LUT_MIPI_PIXEL_HS, LUT_MIPI_PIXEL_VS
 
reg        LUT_MIPI_PIXEL_HS;
reg        LUT_MIPI_PIXEL_VS;
wire [9:0]  LUT_MIPI_PIXEL_D  ;
wire        MIPI_PIXEL_CLK_; 
wire [9:0]  PCK;


wire        RX_CLK;
wire        TX_CLK;
//=======================================================
// Structural coding
//=======================================================
//--INPU MIPI-PIXEL-CLOCK DELAY
CLOCK_DELAY  del1(  .iCLK (MIPI_PIXEL_CLK),  .oCLK (MIPI_PIXEL_CLK_ ) );


// assign LUT_MIPI_PIXEL_HS=MIPI_PIXEL_HS;
// assign LUT_MIPI_PIXEL_VS=MIPI_PIXEL_VS;
assign LUT_MIPI_PIXEL_D =MIPI_PIXEL_D ;



logic [23:0] ram_q;
logic [23:0] ram_d;
logic [14:0] ram_read_address;
logic ram_write_enable;


logic [31:0] fast_mode;



// actualram	actualram_inst (
// 	.address ( ram_address),
// 	.clock ( txclk),
// 	.data (  ram_d),
// 	.wren ( ram_write_enable),
// 	.q ( ram_q)
// 	);


//my code

wire sdram_to_uart_start;
logic start_write_to_dual_port_ram;


always @* begin
	if (SW[7]) begin
		LUT_MIPI_PIXEL_HS = MIPI_PIXEL_HS;
		LUT_MIPI_PIXEL_VS = MIPI_PIXEL_VS;
	end else begin
		LUT_MIPI_PIXEL_HS = 1'b0;
		LUT_MIPI_PIXEL_VS = 1'b0;
	end
	
end

always @* begin				//SWITCH 8 STARTS TRANSMISSION OF DATA TO WIFI MODULE
	if (SW[8]) begin
		sdram_to_uart_start = 1'b0;
	end else begin
		sdram_to_uart_start = 1'b1;
	end
	
end

always @* begin				//SWITCH 9 STARTS TRANSMISSION OF pixels to dual port ram
	if (SW[9]) begin
		start_write_to_dual_port_ram = 1'b0;
	end else begin
		start_write_to_dual_port_ram = 1'b1;
	end
	
	
end

always_comb begin
	if (SW[1]) begin
		fast_mode = 32'd15000;

	end else begin
		fast_mode = 32'd80000;
	end
end

// logic [9:0] sdram_mipi_out;
// logic sdram_read_request;
// logic [7:0] rgbRed;
// logic [7:0] rgbGreen;
// logic [7:0] rgbBlue;
// logic verticalSync;

logic [7:0] data_in;
logic data_in_valid;
logic data_end;
logic data_accepted;
logic [15:0] table_number_ascii;
logic start;
logic txclk;
logic rxclk;
logic busy;
logic sendPOST;


logic [23:0] dualportramq;
logic [14:0] dualportramreadaddress;




// instantiate wifi_rtl
wifi_rtl wifi_rtl_inst(
    .CLOCK_50(CLOCK_50),
    .data_in(data_in),
    .data_in_valid(data_in_valid),
    .data_end(data_end),
    .data_accepted(data_accepted),
    .table_number_ascii(table_number_ascii),
    .reset(reset),
    .start(start),
    .GPIO(GPIO),
    .txclk(txclk),
    .rxclk(rxclk),
    .increment_table_number(increment_table_number),
    .sendPOST(sendPOST)
);


logic [14:0] i;

logic [7:0] table_number;

logic [47:0] current_transitted_pixel;

logic [7:0] ascii_index;

logic [15:0] j;

logic [31:0] k;

logic [15:0] l;




enum {Rst, Write, SendPOSTstate, Finished, actuallyFinished, FinalSendPOSTWrite, FinalFinished, FinalSendPOST, actuallyFinishedDeadass} state;


always_ff @(posedge txclk) begin
    if(!KEY[0] || state == Rst) begin
        if(SW[8]) begin
            i <= 1;	
            table_number <= 0;
            state <= Write;
			ascii_index <= 0;
			j <= 0;
			k <= 0;
			//l <= 0;
			
        end else begin
			i <= 0;
            state <= Rst;
			j <= 0;
		end
    end else begin
        case (state)
            Write: begin
                if(j < 3960) begin			// 3960
                    state <= Write;
                    if(data_accepted) begin
                        j <= j + 1;
						if(ascii_index == 5) begin
							ascii_index <= 0;
							i <= i + 1;
						end else begin
							ascii_index <= ascii_index + 1;
						end	
                    end
                    if(increment_table_number) begin
                        table_number <= table_number + 1;
                    end
                end else begin
                    state <= Finished;
                end
            end
            SendPOSTstate: begin
                if(data_accepted) begin
                    state <= actuallyFinished;
                end else begin
                    state <= SendPOSTstate;
                end
            end
            
            Finished: begin
                state <= SendPOSTstate;
            end
            actuallyFinished: begin
				j <= 0;
				table_number <= 0;
				if( i < 19200 ) begin	//19200 + 3610 = 22810
					if(k < fast_mode) begin	//25000 tcp	//80000 http
						state <= actuallyFinished;
						k <= k + 1;
					end else begin
						k <= 0;
						state <= Write;
						j <= 0;
					end
				end else begin
                	state <= FinalSendPOSTWrite;
				end
            end
			FinalSendPOSTWrite: begin
				if(l < 3950) begin
					state <= FinalSendPOSTWrite;
					if(data_accepted) begin
						l <= l + 1;
					end
				end else begin
					state <= FinalFinished;
				end
			end
			FinalFinished: begin
				state <= FinalSendPOST;
			end
			FinalSendPOST: begin
				if(data_accepted) begin
					state <= actuallyFinishedDeadass;
				end else begin
					state <= FinalSendPOST;
				end
			end
			actuallyFinishedDeadass: begin
				state <= actuallyFinishedDeadass;
			end
        endcase
    end
    

end

always_comb begin
    case (state)
        Rst: begin
            data_in = 0;
            data_in_valid = 0;
            data_end = 0;
            start = 0;
            LEDR = 10'b0000000001;
            sendPOST = 0;

			dualportramreadaddress = 0;

        end
        Write: begin
            if(ascii_index == 0) begin
				data_in = current_transitted_pixel[47:40];
			end else if(ascii_index == 1) begin
				data_in = current_transitted_pixel[39:32];
			end else if(ascii_index == 2) begin
				data_in = current_transitted_pixel[31:24];
			end else if(ascii_index == 3) begin
				data_in = current_transitted_pixel[23:16];
			end else if(ascii_index == 4) begin
				data_in = current_transitted_pixel[15:8];
			end else begin
				data_in = current_transitted_pixel[7:0];
			end

            data_in_valid = 1;
            data_end = 0;
            start = 1;
            LEDR = 10'b0000000010;
            sendPOST = 0;

			dualportramreadaddress = i;	
			
        end
        SendPOSTstate: begin
            data_in = 0;
            data_in_valid = 1;
            data_end = 0;
            start = 1;
            LEDR = 10'b0000001000;
            sendPOST = 1;

			dualportramreadaddress = i;

        end
        Finished: begin
            data_in = 0;
            data_in_valid = 0;
            data_end = 1;
            start = 0;
            LEDR = 10'b0000000100;
            sendPOST = 0;

			dualportramreadaddress = i;
        end
        actuallyFinished: begin
            data_in = 0;
            data_in_valid = 0;
            data_end = 0;
            start = 0;
            LEDR = 10'b0000010000;
            sendPOST = 0;

			dualportramreadaddress = i;
        end
		FinalSendPOSTWrite: begin
			data_in = 8'h30;	//0
			data_in_valid = 1;
            data_end = 0;
            start = 1;
            LEDR = 10'b0000100000;
            sendPOST = 0;

			dualportramreadaddress = 0;	
		end
		FinalFinished: begin
			data_in = 0;
            data_in_valid = 0;
            data_end = 1;
            start = 0;
            LEDR = 10'b0001000000;
            sendPOST = 0;

			dualportramreadaddress = 0;
		end
		FinalSendPOST: begin
			data_in = 0;
            data_in_valid = 1;
            data_end = 0;
            start = 1;
            LEDR = 10'b0010000000;
            sendPOST = 1;

			dualportramreadaddress = 0;
		end
		actuallyFinishedDeadass: begin
			data_in = 0;
			data_in_valid = 0;
			data_end = 0;
			start = 0;
			LEDR = 10'b0100000000;
			sendPOST = 0;

			dualportramreadaddress = 0;
		end
    endcase
end


always_comb begin
    case (table_number)
        8'd0: table_number_ascii = 16'h3030;
        8'd1: table_number_ascii = 16'h3031;
        8'd2: table_number_ascii = 16'h3032;
        8'd3: table_number_ascii = 16'h3033;
        8'd4: table_number_ascii = 16'h3034;
        8'd5: table_number_ascii = 16'h3035;
        8'd6: table_number_ascii = 16'h3036;
        8'd7: table_number_ascii = 16'h3037;
        8'd8: table_number_ascii = 16'h3038;
        8'd9: table_number_ascii = 16'h3039;
        8'd10: table_number_ascii = 16'h3130;
        8'd11: table_number_ascii = 16'h3131;
        8'd12: table_number_ascii = 16'h3132;
        8'd13: table_number_ascii = 16'h3133;
        8'd14: table_number_ascii = 16'h3134;
        8'd15: table_number_ascii = 16'h3135;
        8'd16: table_number_ascii = 16'h3136;
        8'd17: table_number_ascii = 16'h3137;
        8'd18: table_number_ascii = 16'h3138;
        8'd19: table_number_ascii = 16'h3139;
        8'd20: table_number_ascii = 16'h3230;
        default: table_number_ascii = 16'h3030;
    endcase
end

//convert 8 bit number corresponding ascii in hex number

always_comb begin
	case(dualportramq[23:20])
		4'h0: current_transitted_pixel[47:40] = 8'h30;
		4'h1: current_transitted_pixel[47:40] = 8'h31;
		4'h2: current_transitted_pixel[47:40] = 8'h32;
		4'h3: current_transitted_pixel[47:40] = 8'h33;
		4'h4: current_transitted_pixel[47:40] = 8'h34;
		4'h5: current_transitted_pixel[47:40] = 8'h35;
		4'h6: current_transitted_pixel[47:40] = 8'h36;
		4'h7: current_transitted_pixel[47:40] = 8'h37;
		4'h8: current_transitted_pixel[47:40] = 8'h38;
		4'h9: current_transitted_pixel[47:40] = 8'h39;
		4'ha: current_transitted_pixel[47:40] = 8'h41;
		4'hb: current_transitted_pixel[47:40] = 8'h42;
		4'hc: current_transitted_pixel[47:40] = 8'h43;
		4'hd: current_transitted_pixel[47:40] = 8'h44;
		4'he: current_transitted_pixel[47:40] = 8'h45;
		4'hf: current_transitted_pixel[47:40] = 8'h46;
	endcase

	case(dualportramq[19:16])
		4'h0: current_transitted_pixel[39:32] = 8'h30;
		4'h1: current_transitted_pixel[39:32] = 8'h31;
		4'h2: current_transitted_pixel[39:32] = 8'h32;
		4'h3: current_transitted_pixel[39:32] = 8'h33;
		4'h4: current_transitted_pixel[39:32] = 8'h34;
		4'h5: current_transitted_pixel[39:32] = 8'h35;
		4'h6: current_transitted_pixel[39:32] = 8'h36;
		4'h7: current_transitted_pixel[39:32] = 8'h37;
		4'h8: current_transitted_pixel[39:32] = 8'h38;
		4'h9: current_transitted_pixel[39:32] = 8'h39;
		4'ha: current_transitted_pixel[39:32] = 8'h41;
		4'hb: current_transitted_pixel[39:32] = 8'h42;
		4'hc: current_transitted_pixel[39:32] = 8'h43;
		4'hd: current_transitted_pixel[39:32] = 8'h44;
		4'he: current_transitted_pixel[39:32] = 8'h45;
		4'hf: current_transitted_pixel[39:32] = 8'h46;
	endcase

	case(dualportramq[15:12])
		4'h0: current_transitted_pixel[31:24] = 8'h30;
		4'h1: current_transitted_pixel[31:24] = 8'h31;
		4'h2: current_transitted_pixel[31:24] = 8'h32;
		4'h3: current_transitted_pixel[31:24] = 8'h33;
		4'h4: current_transitted_pixel[31:24] = 8'h34;
		4'h5: current_transitted_pixel[31:24] = 8'h35;
		4'h6: current_transitted_pixel[31:24] = 8'h36;
		4'h7: current_transitted_pixel[31:24] = 8'h37;
		4'h8: current_transitted_pixel[31:24] = 8'h38;
		4'h9: current_transitted_pixel[31:24] = 8'h39;
		4'ha: current_transitted_pixel[31:24] = 8'h41;
		4'hb: current_transitted_pixel[31:24] = 8'h42;
		4'hc: current_transitted_pixel[31:24] = 8'h43;
		4'hd: current_transitted_pixel[31:24] = 8'h44;
		4'he: current_transitted_pixel[31:24] = 8'h45;
		4'hf: current_transitted_pixel[31:24] = 8'h46;
	endcase

	case(dualportramq[11:8])
		4'h0: current_transitted_pixel[23:16] = 8'h30;
		4'h1: current_transitted_pixel[23:16] = 8'h31;
		4'h2: current_transitted_pixel[23:16] = 8'h32;
		4'h3: current_transitted_pixel[23:16] = 8'h33;
		4'h4: current_transitted_pixel[23:16] = 8'h34;
		4'h5: current_transitted_pixel[23:16] = 8'h35;
		4'h6: current_transitted_pixel[23:16] = 8'h36;
		4'h7: current_transitted_pixel[23:16] = 8'h37;
		4'h8: current_transitted_pixel[23:16] = 8'h38;
		4'h9: current_transitted_pixel[23:16] = 8'h39;
		4'ha: current_transitted_pixel[23:16] = 8'h41;
		4'hb: current_transitted_pixel[23:16] = 8'h42;
		4'hc: current_transitted_pixel[23:16] = 8'h43;
		4'hd: current_transitted_pixel[23:16] = 8'h44;
		4'he: current_transitted_pixel[23:16] = 8'h45;
		4'hf: current_transitted_pixel[23:16] = 8'h46;
	endcase

	case(dualportramq[7:4])
		4'h0: current_transitted_pixel[15:8] = 8'h30;
		4'h1: current_transitted_pixel[15:8] = 8'h31;
		4'h2: current_transitted_pixel[15:8] = 8'h32;
		4'h3: current_transitted_pixel[15:8] = 8'h33;
		4'h4: current_transitted_pixel[15:8] = 8'h34;
		4'h5: current_transitted_pixel[15:8] = 8'h35;
		4'h6: current_transitted_pixel[15:8] = 8'h36;
		4'h7: current_transitted_pixel[15:8] = 8'h37;
		4'h8: current_transitted_pixel[15:8] = 8'h38;
		4'h9: current_transitted_pixel[15:8] = 8'h39;
		4'ha: current_transitted_pixel[15:8] = 8'h41;
		4'hb: current_transitted_pixel[15:8] = 8'h42;
		4'hc: current_transitted_pixel[15:8] = 8'h43;
		4'hd: current_transitted_pixel[15:8] = 8'h44;
		4'he: current_transitted_pixel[15:8] = 8'h45;
		4'hf: current_transitted_pixel[15:8] = 8'h46;
	endcase

	case(dualportramq[3:0])
		4'h0: current_transitted_pixel[7:0] = 8'h30;
		4'h1: current_transitted_pixel[7:0] = 8'h31;
		4'h2: current_transitted_pixel[7:0] = 8'h32;
		4'h3: current_transitted_pixel[7:0] = 8'h33;
		4'h4: current_transitted_pixel[7:0] = 8'h34;
		4'h5: current_transitted_pixel[7:0] = 8'h35;
		4'h6: current_transitted_pixel[7:0] = 8'h36;
		4'h7: current_transitted_pixel[7:0] = 8'h37;
		4'h8: current_transitted_pixel[7:0] = 8'h38;
		4'h9: current_transitted_pixel[7:0] = 8'h39;
		4'ha: current_transitted_pixel[7:0] = 8'h41;
		4'hb: current_transitted_pixel[7:0] = 8'h42;
		4'hc: current_transitted_pixel[7:0] = 8'h43;
		4'hd: current_transitted_pixel[7:0] = 8'h44;
		4'he: current_transitted_pixel[7:0] = 8'h45;
		4'hf: current_transitted_pixel[7:0] = 8'h46;
	endcase
end




dualramportwritefsm duram(
	.READ_Request(READ_Request),
	.H_Cont(VGA_H_CNT),
	.V_Cont(VGA_V_CNT),
	.input_Red(RED),
	.input_Green(GREEN),
	.input_Blue(BLUE),
	.vga_clk(VGA_CLK),
	.reset(~KEY[0]),
	.read_clk(txclk),
	.output_q(dualportramq),
	.read_address(dualportramreadaddress)
);


// //------UART OFF --
// assign UART_RTS =0; 
// assign UART_TXD =0; 
//------HEX OFF --
assign HEX2           = 7'h7F;
assign HEX3           = 7'h7F;
assign HEX4           = 7'h7F;
assign HEX5           = 7'h7F;

//------ MIPI BRIGE & CAMERA RESET  --
assign CAMERA_PWDN_n  = 1; 
assign MIPI_CS_n      = 0; 
assign MIPI_RESET_n   = RESET_N ;

//------ CAMERA MODULE I2C SWITCH  --
assign I2C_RELEASE    = CAMERA_MIPI_RELAESE & MIPI_BRIDGE_RELEASE; 
assign CAMERA_I2C_SCL =( I2C_RELEASE  )?  CAMERA_I2C_SCL_AF  : CAMERA_I2C_SCL_MIPI ;   


 
//----- RESET RELAY  --		
RESET_DELAY			u2	(	
							.iRST  ( KEY[0] ),
                     .iCLK  ( CLOCK2_50 ),
							.oRST_0( DLY_RST_0 ),
							.oRST_1( DLY_RST_1 ),
							.oRST_2( DLY_RST_2 ),					
						   .oREADY( RESET_N)  
							
						);
 
//------ MIPI BRIGE & CAMERA SETTING  --  
MIPI_BRIDGE_CAMERA_Config    cfin(
                      .RESET_N           ( RESET_N ), 
                      .CLK_50            ( CLOCK2_50 ), 
                      .MIPI_I2C_SCL      ( MIPI_I2C_SCL ), 
                      .MIPI_I2C_SDA      ( MIPI_I2C_SDA ), 
                      .MIPI_I2C_RELEASE  ( MIPI_BRIDGE_RELEASE ),  
                      .CAMERA_I2C_SCL    ( CAMERA_I2C_SCL_MIPI ),
                      .CAMERA_I2C_SDA    ( CAMERA_I2C_SDA ),
                      .CAMERA_I2C_RELAESE( CAMERA_MIPI_RELAESE )
             );
				 
//------MIPI / VGA REF CLOCK  --
pll_test pll_ref(
	                   .inclk0 ( CLOCK3_50 ),
	                   .areset ( ~KEY[0]   ),
	                   .c0( MIPI_REFCLK    ) //20Mhz

    );
	 
//------MIPI / VGA REF CLOCK  -
VIDEO_PLL pll_ref1(
	                   .inclk0 ( CLOCK2_50 ),
	                   .areset ( ~KEY[0] ),
	                   .c0( VGA_CLK )        //25 Mhz	
    );	 
//------SDRAM CLOCK GENNERATER  --
sdram_pll u6(
		               .areset( 0 ) ,     
		               .inclk0( CLOCK_50 ),              
		               .c1    ( DRAM_CLK ),       //100MHZ   -90 degree
		               .c0    ( SDRAM_CTRL_CLK )  //100MHZ     0 degree 							
		              
	               );		
						
//------SDRAM CONTROLLER --
Sdram_Control	   u7	(	//	HOST Side						
						   .RESET_N     ( KEY[0] ),
							.CLK         ( SDRAM_CTRL_CLK ) , 
							//	FIFO Write Side 1
							.WR1_DATA    ( LUT_MIPI_PIXEL_D[9:0] ),
							.WR1         ( LUT_MIPI_PIXEL_HS & LUT_MIPI_PIXEL_VS ) ,
							
							.WR1_ADDR    ( 0 ),
                     .WR1_MAX_ADDR( 640*480 ),
						   .WR1_LENGTH  ( 256 ) , 
		               .WR1_LOAD    ( !DLY_RST_0 ),
							.WR1_CLK     ( MIPI_PIXEL_CLK_),

                     //	FIFO Read Side 1
						   .RD1_DATA    ( SDRAM_RD_DATA[9:0] ),
				        	.RD1         ( READ_Request ),
				        	.RD1_ADDR    (0 ),
                     .RD1_MAX_ADDR( 640*480 ),
							.RD1_LENGTH  ( 256  ),
							.RD1_LOAD    ( !DLY_RST_1 ),
							.RD1_CLK     ( VGA_CLK ),

					//  	//FIFO Read Side 2
					// 	   .RD2_DATA    ( sdram_mipi_out),
				    //     	.RD2         ( sdram_read_request ),
				    //     	.RD2_ADDR    ( 0),
					//  .RD2_MAX_ADDR(640*480),
					//  		.RD2_LENGTH  ( 256),
					// 		.RD2_LOAD    (!DLY_RST_1 ),
					// 		.RD2_CLK     ( txclk),
											
							//	SDRAM Side
						   .SA          ( DRAM_ADDR ),
							.BA          ( DRAM_BA ),
							.CS_N        ( DRAM_CS_N ),
							.CKE         ( DRAM_CKE ),
							.RAS_N       ( DRAM_RAS_N ),
							.CAS_N       ( DRAM_CAS_N ),
							.WE_N        ( DRAM_WE_N ),
							.DQ          ( DRAM_DQ ),
							.DQM         ( DRAM_DQM  )
						   );	 	 
	 
//------ CMOS CCD_DATA TO RGB_DATA -- 

// RAW2RGB_J			myrgb	(	
// 							.RST          ( 1'b1 ),
// 							.iDATA        (  sdram_mipi_out),

// 							//-----------------------------------
// 					 .VGA_CLK      (txclk),
// 					 .READ_Request (sdram_read_request),
// 					 .VGA_VS       (1'b1),	
// 							.VGA_HS       ( verticalSync) , 
	                  			
// 							.oRed         (rgbRed),
// 							.oGreen       ( rgbGreen),
// 							.oBlue        ( rgbBlue)

// );

RAW2RGB_J				u4	(	
							.RST          ( VGA_VS ),
							.iDATA        ( SDRAM_RD_DATA[9:0] ),

							//-----------------------------------
                     .VGA_CLK      ( VGA_CLK ),
                     .READ_Request ( READ_Request ),
                     .VGA_VS       ( VGA_VS ),	
							.VGA_HS       ( VGA_HS ) , 
	                  			
							.oRed         ( RED  ),
							.oGreen       ( GREEN),
							.oBlue        ( BLUE )


							);	





//------AOTO FOCUS ENABLE  --
AUTO_FOCUS_ON  vd( 
                      .CLK_50      ( CLOCK2_50 ), 
                      .I2C_RELEASE ( I2C_RELEASE ), 
                      .AUTO_FOC    ( AUTO_FOC )
               ) ;
					

//------AOTO FOCUS ADJ  --
FOCUS_ADJ adl(
                      .CLK_50        ( CLOCK2_50 ) , 
                      .RESET_N       ( I2C_RELEASE ), 
                      .RESET_SUB_N   ( I2C_RELEASE ), 
                      .AUTO_FOC      ( KEY[3] & AUTO_FOC ), 
                      .SW_Y          ( 0 ),
                      .SW_H_FREQ     ( 0 ),   
                      .SW_FUC_LINE   ( SW[3] ),   
                      .SW_FUC_ALL_CEN( SW[3] ),
                      .VIDEO_HS      ( VGA_HS ),
                      .VIDEO_VS      ( VGA_VS ),
                      .VIDEO_CLK     ( VGA_CLK ),
		                .VIDEO_DE      (READ_Request) ,
                      .iR            ( R_AUTO ), 
                      .iG            ( G_AUTO ), 
                      .iB            ( B_AUTO ), 
                      .oR            ( VGA_R ) , 
                      .oG            ( VGA_G ) , 
                      .oB            ( VGA_B ) , 
                      
                      .READY         ( READY ),
                      .SCL           ( CAMERA_I2C_SCL_AF ), 
                      .SDA           ( CAMERA_I2C_SDA )
);

//------VGA Controller  --

VGA_Controller		u1	(	//	Host Side
							 .oRequest( READ_Request ),
							 .iRed    ( RED    ),
							 .iGreen  ( GREEN  ),
							 .iBlue   ( BLUE   ),
							 
							 //	VGA Side
							 .oVGA_R  ( R_AUTO[7:0] ),
							 .oVGA_G  ( G_AUTO[7:0] ),
							 .oVGA_B  ( B_AUTO[7:0] ),
							 .oVGA_H_SYNC( VGA_HS ),
							 .oVGA_V_SYNC( VGA_VS ),
							 .oVGA_SYNC  ( VGA_SYNC_N ),
							 .oVGA_BLANK ( VGA_BLANK_N ),
							 //	Control Signal
							 .iCLK       ( VGA_CLK ),
							 .iRST_N     ( DLY_RST_2 ),
							 .H_Cont     ( VGA_H_CNT ),						
						    .V_Cont     ( VGA_V_CNT )								
		);	


//------VS FREQUENCY TEST = 60HZ --
							
FpsMonitor uFps( 
	   .clk50    ( CLOCK2_50 ),
	   .vs       ( LUT_MIPI_PIXEL_VS ),
	
	   .fps      (),
	   .hex_fps_h( HEX1 ),
	   .hex_fps_l( HEX0 )
);


//--LED DISPLAY--
CLOCKMEM  ck1 ( .CLK(VGA_CLK )   ,.CLK_FREQ  (25000000  ) , . CK_1HZ (D8M_CK_HZ   )  )        ;//25MHZ
CLOCKMEM  ck2 ( .CLK(MIPI_REFCLK   )   ,.CLK_FREQ  (20000000   ) , . CK_1HZ (D8M_CK_HZ2  )  ) ;//20MHZ
CLOCKMEM  ck3 ( .CLK(MIPI_PIXEL_CLK_)   ,.CLK_FREQ  (25000000  ) , . CK_1HZ (D8M_CK_HZ3  )  )  ;//25MHZ


//assign LEDR = { D8M_CK_HZ ,D8M_CK_HZ2,D8M_CK_HZ3 ,5'h0,CAMERA_MIPI_RELAESE ,MIPI_BRIDGE_RELEASE  } ; 

endmodule
